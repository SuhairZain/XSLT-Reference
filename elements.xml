<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE docset [
	
	<!ENTITY template-content '
		<element ref="if" />
		<element ref="choose" />
		<element ref="for-each" />
		<element ref="value-of" />
		<element ref="comment" />
		<element ref="text" />
		<element ref="param" />
		<element ref="variable" />
		<element ref="number" />
	'>

	<!ENTITY param-content '
		<element ref="if" />
		<element ref="choose" />
		<element ref="for-each" />
		<element ref="value-of" />
		<element ref="text" />
		<element ref="number" />
	'>

	<!ENTITY root-content '
		<element ref="import" />
		<element ref="include" />
		<element ref="key" />
		<element ref="attribute-set" />
		<element ref="output" />
	'>
]>
<docset name="XSLT 1.0">
	
	<!-- Attributes for later reference -->
	<attribute name="match" content="pattern" />
	<attribute name="name" content="string" />
	<attribute name="mode" content="string" />
	<attribute name="select" content="expression" />
	<attribute name="test" content="condition" />
	<attribute name="disable-output-escaping" content="boolean" />

	<!-- Elements for later reference -->
	<element name="stylesheet">
		<attribute name="version" content="enum" values="1.0" required="yes" />
		<attribute name="exclude-result-prefixes" content="nmtokens" />
		<attribute name="extension-element-prefixes" content="nmtokens" />
		
		&root-content;
		
	</element>

	<element name="transform">
		<description>
			<p>This is an alias for the <ref>stylesheet</ref> element - almost never used.</p>
		</description>
		<attribute name="version" content="enum" values="1.0" required="yes" />
		
		&root-content;
		
	</element>

	<element name="template">
		<description>
			<p>
				A template defines a chunk of output. When using the <var>match</var> attribute,
				it can only be invoked by an <ref>apply-templates</ref> instruction (which can process multiple
				elements and their templates in a single operation), and is guaranteed to have the context of
				an element matching the pattern in the <var>match</var> attribute.
			</p>
			<p>
				When using the <var>name</var> attribute, the template can be manually invoked by
				a <ref>call-template</ref> instruction, thus resembling a <em>sub-routine</em> in other
				languages.
			</p>
			<p>
				The <var>mode</var> attribute facilitates multiple outputs for the same element, e.g. if
				an <code><![CDATA[<article>]]></code> needs a short version for the Table of Contents at
				the top of the output, and a longer version for the actual article content.
			</p>
			<note>
				It's perfectly valid to have both a <var>match</var> and a <var>name</var> attribute on a
				template, if it makes sense. But you're required to use at least one of them.
			</note>
		</description>
		<attribute ref="match" />
		<attribute ref="name" />
		<attribute ref="mode" />
		<attribute name="priority" content="number" />

		&template-content;
		
	</element>

	<!-- Output elements -->
	<element name="value-of">
		<attribute ref="select" required="yes" />
		<attribute ref="disable-output-escaping" />
	</element>
	
	<element name="text">
		<attribute ref="disable-output-escaping" />
	</element>
	
	<element name="comment">
		<description>
			<p>Use this to generate a comment in the output.</p>
		</description>
	</element>
	
	<element name="attribute">
		<description>
			<p>
				Generates an attribute on the element being output. Must precede any
				content generated for an element (i.e.: text, child elements, comments etc.)
			</p>
			<note>
				Can be used to override an attribute you've already set, as
				duplicate attribute names are not allowed in XML.
			</note>
		</description>
		<attribute ref="name" required="yes" />
		<attribute name="namespace" content="URI" />
		&template-content;
	</element>
	
	<element name="element">
		<description>
			<p>
				Only necessary if you don't know the name of the element, or if you need to create
				the element in a specific namespace. Otherwise it's much better to just use the
				element tag directly (i.e., just use <code><![CDATA[<div>]]></code>
				instead of <code><![CDATA[<xsl:element name="div">]]></code>).
			</p>
		</description>
		<attribute ref="name" />
		<attribute name="namespace" content="URI" />
		&template-content;
	</element>
	
	<element name="processing-instruction">
		<attribute ref="name" />
	</element>
	
	<element name="number">
		<attribute name="count" content="expression" />
		<attribute name="level" content="enum" values="single|multiple|any" />
		<attribute name="from" content="expression" />
		<attribute name="value" content="expression" />
		<attribute name="format" content="string" />
		<attribute name="lang" content="string" />
		<attribute name="letter-value" content="enum" values="alphabetic|traditional" />
		<attribute name="grouping-separator" content="char" />
		<attribute name="grouping-size" content="number" />
	</element>
	
	<!-- Program flow elements -->
	<element name="apply-templates">
		<description>
			<p>
				Collects the nodes specified by the <var>select</var> attribute and
				starts processing them using matching templates.
			</p>
			<p>
				Using the <var>mode</var> attribute restricts the applied templates to
				only those with an identical mode attribute.
			</p>
			<note>
				If no select attribute is present, it defaults to "*", i.e. the children
				of the current node.
			</note>
		</description>
		<attribute ref="select" />
		<attribute ref="mode" />
		
		<element ref="sort" />
		<element ref="with-param" />
	</element>

	<element name="call-template">
		<description>
			<p>
				Explicitly call a named <ref>template</ref> (a template with a name attribute).
				The template will execute with the context at the point of this instruction.
			</p>
		</description>
		<attribute ref="name" />
		<element ref="with-param" />
	</element>

	<element name="with-param">
		<attribute ref="name" />
		<attribute ref="select" />
	</element>
	
	<element name="for-each">
		<attribute ref="select" required="yes" />
		<element ref="sort" />
		
		&template-content;
		
	</element>
	
	<element name="if">
		<attribute ref="test" required="yes" />
		
		&template-content;
		
	</element>

	<element name="choose">
		<element ref="when" />
		<element ref="otherwise" />
	</element>

	<element name="when">
		<attribute ref="test" required="yes" />
		&template-content;
	</element>

	<element name="otherwise">
		&template-content;
	</element>
	
	<!-- Misc. elements -->
	<element name="variable">
		<attribute ref="name" required="yes" />
		<attribute ref="select" />
		
		&param-content;
		
	</element>
	
	<element name="strip-space">
		<description>
			<p>
				Instructs the processor to remove all white-space nodes from specific
				elements in the source document before they're handled by XSLT.
			</p>
		</description>
		<attribute name="elements" content="nmtokens" />
	</element>
	
	<element name="preserve-space">
		<description>
			<p>
				Instructs the processor to preserve white-space nodes from specific
				elements in the source document before they're handled by XSLT.
			</p>
			<note>
				The default behavior is to preserve white-space, so this element is provided
				so you can preserve specific elements' white-space, in case <ref>strip-space</ref>
				has been set to "all others" ("*").
			</note>
		</description>
		<attribute name="elements" content="nmtokens" />
	</element>
	
	<element name="param">
		<description>
			<p>
				Defines a value that can be used in many places, which should be easily changeable
				from e.g. the top of the file. Once defined, a parameter can be used by prefixing the name
				with a dollar-sign, e.g. <code><![CDATA[<xsl:value-of select="$primary-color">]]></code>
				or <code><![CDATA[<div class="{$selected-class}">]]></code>.
			</p>
			<p>
				A parameter is very similar to a <ref>variable</ref>, and none of them can be changed
				within the same transformation.
			</p>
			<note>
				The difference between a parameter and a <ref>variable</ref> is that a parameter can be set
				from the XSLT Processor when invoking the transform.
			</note>
		</description>
		<attribute ref="name" required="yes" />
		<attribute name="select" />
		
		&param-content;
		
	</element>
	
	<element name="attribute-set">
		<attribute ref="name" required="yes" />
		<element ref="attribute" />
	</element>
	
	<element name="decimal-format">
		<attribute ref="name" />
		<attribute name="decimal-separator" content="char" />
		<attribute name="grouping-separator" content="char" />
		<attribute name="infinity" content="string" />
		<attribute name="minus-sign" content="char" />
		<attribute name="NaN" content="string" />
		<attribute name="percent" content="char" />
		<attribute name="per-mille" content="char" />
		<attribute name="zero-digit" content="char" />
		<attribute name="digit" content="char" />
		<attribute name="pattern-separator" content="char" />
	</element>
	
	<element name="sort">
		<description>
			<p>
				If present, this <strong>must</strong> be the first element inside a <ref>for-each</ref> or an
				<ref>apply-templates</ref> instruction.
			</p>
			<note>
				Multiple sort elements are allowed.
			</note>
		</description>
		<attribute ref="select" />
		<attribute name="data-type" content="enum" values="text|number" />
		<attribute name="order" content="enum" values="ascending|descending" />
		<attribute name="case-order" content="enum" values="upper-first|lower-first" />
		<attribute name="lang" content="string" />
	</element>
	
	<element name="key">
		<description>
			<p>
				Creates a named index of elements matching the expression in the <var>match</var> attribute.
				The value retrieved from the <var>use</var> attribute is stored as the index value.
			</p>
		</description>
		<attribute ref="match" required="yes" />
		<attribute ref="name" required="yes" />
		<attribute name="use" content="expression" required="yes" />
	</element>
	
	<element name="include">
		<attribute name="href" content="URI" required="yes" />
	</element>
		
	<element name="import">
		<attribute name="href" content="URI" required="yes" />
	</element>
	
	<element name="output">
		<attribute name="method" content="enum" values="html|xml|text" />
		<attribute name="indent" content="boolean" />
		<attribute name="omit-xml-declaration" content="boolean" />
		<attribute name="doctype-public" content="URI" />
		<attribute name="doctype-system" content="URI" />
		<attribute name="cdata-section-elements" content="nmtokens" />
	</element>
	
</docset>
